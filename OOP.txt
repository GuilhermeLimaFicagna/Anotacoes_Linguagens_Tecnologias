--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ANOTAÇÕES SOBRE PROGRAMAÇÃO ORIENTADA A OBJETO (OOP) ☺
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

CLASSES E OBJETOS ☺

- Dois conceitos fundamentais em programação orientada a objetos. Para começar a intender o conceito classes e objetos vamos começar usando um exemplo do mundo de futebol para ligar as coisas e ter melhor compreensão:

	- Jogadores.. podemos dizer que eles tem suas características certo? Por exemplo: Nome, Cabelo, Número, Nacionalidade etc..

		- Se pararmos para pensar temos um GRUPO de jogadores, e cada um desses jogadores tem seus ATRIBUTOS, Nome, cabelo..

- Dessa forma podemos enxergar um novo conceito que é o de classe, que é um grupo de objetos e cada objeto tem sua característica, ou melhor, atributo. Para enxergarmos melhor podemos ver o exemplo abaixo:

		Classe Jogador
		    nome:
		    cabelo:		
		    número:
		    nacionalidade:	
			
		- Agora que já temos os atributos da nossa classe vamos pegar 2 exemplos de jogadores, ou melhor dizendo, objetos dessa classe

		    nome: Neymar jr
		    cabelo: raspado	
		    número: 10
		    nacionalidade: Brasileira	

		    nome: Cristiano Ronaldo 
		    cabelo: curto	
		    número: 7
		    nacionalidade: Português

		- Nesses dois exemplos podemos ver que Neymar e Cristiano são objetos da classe jogador

- Sabendo disso podemos ver que, um objeto é uma INSTÂNCIA de uma classe, ou seja, Um objeto é um jogador real criado a partir da ideia de jogador. A classe é o conceito, o objeto é o jogador real.

--------------------------------------------------------------------------------------------------->

- Os objetos de uma classe também podem ter comportamentos. Que são ações que os objetos fazem ou sofrem, podemos chamar de MÉTODOS(). Para exemplificar podemos dizer que os jogadores da classe Jogador, tem ações como por exemplo passarBola() e também fazerGol(). Então nossa classe ficaria assim:

		Classe Jogador
		    nome:
		    cabelo:		
		    número:
		    nacionalidade:		* Não é obrigatório, mas é uma boa pratica sempre declarar
		                  		       atributos por primeiro e depois métodos *
		    passarBola()
		    fazerGol()


- Desse modo concluímos que todo classe pode ter atributos(características) e métodos(ações). E que todo objeto é uma instancia da classe.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

RELAÇÕES ENTRE CLASSES ☺

- Na Programação Orientada a Objetos (POO), os objetos e classes podem se relacionar de diferentes formas para representar melhor o mundo real e organizar o código de maneira mais eficiente. Entre os principais tipos de relação, temos:

	- Herança: é um tipo a parte. 

	- Associação, é o tipo mais genérico de relação entre classes. E que a partir dela, temos dois tipos mais específicos.

		- Agregação: uma associação com vínculo mais fraco.

		- Composição: uma associação com vínculo mais forte e de dependência total entre os objetos..

- Cada uma dessas relações tem um papel importante na forma como as classes interagem entre si e como o sistema é estruturado.

- Mas para entender melhor tudo isso, vamos começar pela Herança, que será o primeiro tipo de relação que vamos abordar.

--------------------------------------------------------------------------------------------------->

HERANÇA ENTRE CLASSES

- A herança permite que uma classe (filha ou subclasse) herde atributos e métodos de outra classe (pai ou superclasse). Para enxergar essa hierarquia, vamos ver um exemplo onde temos uma Classe Estagiário e uma Classe Funcionário:
	
	- Vamos dizer que tanto o estagiário e o funcionário tem características como nome, idade, rg, cpf e que cada um tem uma comportamento. Sendo o do estagiário Bolso Auxilio e o do funcionário Salario, veja abaixo:


		Classe Estagiário 
		    nome:
		    idade:		
		    rg:
		    cpf:

		    bolsaAuxilio()

		Classe Funcionário 
		    nome:
		    idade:
		    rg:
		    cpf:

		    salario()


- Como podemos ver, as duas classes tem o mesmo atributos, o que deixa redundante. Mas com o conceito de herança, isso muda. Como Estagiário e Funcionário são pessoas, podemos criar uma Classe Pessoa. E herdar esses atributos dela veja:

	
				Classe Pessoa 
				    nome:
				    idade:		<-- classe pai ou superclasse
				    rg:
				    cpf:

				      |
			______________|________________
		       |      	 		       |
		       |      	 		       |
		
		Classe Estagiário		Classe Funcionário 
									    <-- classes filhas ou subclasses
		    bolsaAuxilio()		    	salario()



	- Então conseguimos perceber que tanto a Classe Estagiário quanto a Classe Funcionário estão adquirindo por HERANÇA os atributos da Classe Pessoa. se tivéssemos algum método na classe pessoa ele também seria herdado.


- E as vantagens de usar o conceito de herança em oop são:

	- Evita duplicação de código.

	- Facilita a manutenção.

	- Permite especialização: a subclasse pode adicionar ou sobrescrever comportamentos da superclasse.

--------------------------------------------------------------------------------------------------->

ASSOCIAÇÃO, COMPOSIÇÂO E AGREGAÇÃO ENTRE CLASSES

- Associação é quando uma classe "conhece" outra classe e pode usar seus métodos ou acessar seus atributos. Vamos intender isso utilizando um exemplo:

	- Vamos pensar em uma situação que teremos uma Classe Carro e outra Classe Motorista. E podemos dizer que um carro precisa de um motorista para ser conduzido. Daí surge a ideia de associação simples. Um até precisa de um motorista, mas o carro não vai deixar de existir se um motorista não dirigi-lo. Por isso falamos que eles tem uma associação simples:


		|--------------------|     Associação simples     |--------------------|
		|       Carro        |----------------------------|      Motorista     | 
		|--------------------|				  |--------------------| 


- Agora pensando no carro podemos dizer que ele precisa de um motor e rodas para funcionar não é? Por que sem as rodas ou motor ele não funciona. Daí surge a ideia de uma associação mais forte ou melhor dizendo Composição. Então agora vamos criar uma classe motor e roda


						  |--------------------| 
						  |        Roda        | 
						  |--------------------| 
							    |
							    |   <- Associação por composição 
						  	    |
						  	    |
						  	    |
						  	    |
|--------------------| Associação por composição  |--------------------|     Associação simples     |--------------------|
|       Motor        |----------------------------|       Carro        |----------------------------|      Motorista     |
|--------------------|				  |--------------------|			    |--------------------| 
		

	- Na Associação por composição na hora que o objeto Carro for criado, implica em que sejam criados também objeto Motor e objeto Roda.


- Por fim ainda pensando no carro, podemos dizer que ele poderia ter um rádio, ou não também. Um carro não iria deixar de funcionar sem um rádio. Isso indica uma outra ideia, a de associação fraca ou melhor dizendo Agregação. Então por fim vamos criar uma Classe Rádio para concluir nosso exemplo.


						  |--------------------| 
						  |        Roda        | 
						  |--------------------| 
							    |
							    |   <- Associação por composição 
						  	    |
						  	    |
						  	    |
						  	    |
|--------------------| Associação por composição  |--------------------|     Associação simples     |--------------------|
|       Motor        |----------------------------|       Carro        |----------------------------|      Motorista     |
|--------------------|				  |--------------------|			    |--------------------| 
							    |
							    |
						  	    |
						  	    |
						  	    |   <- Associação por agregação
						  	    |
						  |--------------------| 
						  |       Rádio        | 
						  |--------------------| 


	- Na Associação por agregação na hora que o objeto Carro for criado, implica em que o objeto Rádio possa ser criado em outro momento ou não.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

ENCAPSULAMENTO ☺

- O encapsulamento consiste em esconder os detalhes internos de uma classe e proteger seus dados através de níveis de acesso. Esses dados só podem ser acessados e alterados utilizando getters e setters, que são métodos públicos que podem acessar e alterar dados de uma classe. Para entender melhor esse conceito de encapsulamento vamos ver sobre dois tópicos:

	- níveis de acesso: usados para controlar o nível de acesso dos atributos, métodos e classes

	- métodos getters e setters: métodos públicos usados para acessar ou modificar atributos private.

--------------------------------------------------------------------------------------------------->

NÍVEIS DE ACESSO

- Como dito antes, níveis de acesso servem para nível de acesso dos atributos, métodos e classes. Mas quantos níveis existem? conceitualmente, os modificadores de acesso são apenas 4. Veja a seguir:
 
	- Nível público(public): Método, atributo ou classe pode ser acessado de qualquer lugar, sem restrições. 

		- Utilizado quando você deseja que outros desenvolvedores ou partes do seu código possam acessar diretamente um método ou atributo específico.

	- Nível privado(private): O acesso é permitido somente dentro da própria classe onde o membro foi declarado. Nenhuma outra classe (nem mesmo subclasses) pode acessá-lo diretamente.

		- Ideal para encapsular dados sensíveis ou que não devem ser modificados diretamente de fora

	- Nível protegido(protected): Permite acesso dentro da própria classe, nas subclasses (mesmo que estejam em outros pacotes) e também dentro do mesmo pacote.

		- Usado quando você quer permitir que classes filhas (herança) possam acessar ou sobrescrever o membro, mas ainda assim manter algum nível de proteção.

	- Nível predefinido(default): Quando nenhum Nível de acesso é especificado, o acesso é permitido apenas dentro do mesmo pacote (em Java) ou namespace/módulo, dependendo da linguagem.

		- Útil para manter membros visíveis só para componentes relacionados (mesmo grupo de classes). 


- Para melhor visualização desses conceitos veja a tabela a segui:

	|-------------------------------------||----------||-----------||-----------||-----------|
	| Quem pode acessar:                  ||  public  || protected ||  default  ||  private  |
	|-------------------------------------||----------||-----------||-----------||-----------|
	| Mesma classe                        ||   Sim    ||   Sim     ||   Sim     ||   Sim     |
	|-------------------------------------||----------||-----------||-----------||-----------|
	| Mesmo pacote                        ||   Sim    ||   Sim     ||   Sim     ||   Não     |
	|-------------------------------------||----------||-----------||-----------||-----------|
	| Subclasse (outro pacote)            ||   Sim    ||   Sim     ||   Não     ||   Não     |
	|-------------------------------------||----------||-----------||-----------||-----------|
	| Outra classe qualquer               ||   Sim    ||   Não     ||   Não     ||   Não     |
	|-------------------------------------||----------||-----------||-----------||-----------|


--------------------------------------------------------------------------------------------------->

MÉTODOS GET E SET

- Esses dois métodos tem como função poder acessar ou modificar os atributos de nível privado de uma classe, garantindo o encapsulamento e maior controle sobre os dados. Para entender melhor veja as características de cada um:

	- Getter(get): Usado para obter o valor de um atributo privado. Sempre retornando algum valor primitivo. Por conta de ser um método que nunca vai deixar de retornar algo.

	- Setter(set): Usado para alterar o valor de um atributo privado. Geralmente não retorna valor primitivo. Porem pode ser usado para retornar algum valor de status, para indicar sucesso ou erro. Entre outros coisas.

--------------------------------------------------------------------------------------------------->

- Agora que entendemos sobre os dois principais pontos do encapsulamento, podemos dizer que. Encapsulamento é a ação de usar níveis de acesso para proteger os dados (atributos), permitindo acesso apenas por meio de métodos controlados (geralmente getters e setters), e ainda tendo uma lógica de modificação no setter, assim protegendo um dado de ser modificado de qualquer forma. Para entender melhor vamos ver um exemplo de encapsulamento:

	- Vamos usar um pouco da sintaxe de Java para esse exemplo.

	- Vamos imaginar uma Classe ContaBancaria, onde vamos ter uma característica privada que é a do saldo:


		1° public class Estagiário {
		3°     private double saldo; 
		3° }


	- E dentro dessa classe também vamos ter dois métodos públicos, um getter e um setter. Contendo no setter uma regra de validação.


		1°  public class ContaBancaria {    // nossa classe
		2°  
		3°      private double saldo;       // atributo
		4°  
		5°      public double getSaldo() {  // Getter
		6°          return saldo;
		7°      }
		8°  
		9°      public void setSaldo(double valor) { // Setter
		10°         if (valor >= 0) {                // if com validação
		11°             saldo += valor;
		14°         }
		15°     }
		16° }

	- Agora indo para nossa classe principal, vamos fazer uma instancia da Classe ContaBancaria. Logo depois fazer alterações com o setter e depois mostrar na tela com getter.


		1°  public class Main {
		2°      public static void main(String[] args) {
		3°          // Instanciando a classe
		4°          ContaBancaria conta = new ContaBancaria();
		5°  
		6°          // Usando o método setter para colocar valor
		7°          conta.setSaldo(10);
		8°          conta.setSaldo(-10); // valor inválido, por conta de encapsulamento 
		9°  
		10°         // Exibindo o saldo com o getter
		11°         System.out.println("Saldo atual: R$ " + conta.getSaldo());
		12°     }
		13° }


- A linha 7° é a com a maior importância, no contexto de encapsulamento, por conta de ser ela que protege o atributo " saldo " de ser somado -10 a ele. Por conta da regra de validação. Daí vem o conceito de encapsulamento, que protege os atributos da classe, permitindo o acesso apenas por meio de métodos controlados. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
OVERLOADING(SOBRECARGA) E OVERRIDING(SOBRESCRITA) ENTRE MÉTODOS ☺

- Dois conceitos fundamentais relacionados à definição e ao uso de métodos, Ambos estão ligados ao polimorfismo, mas atuam de maneiras diferentes. Para intender melhor veja como cada um funciona:

	-  Overloading (Sobrecarga): É a sobrecarga de métodos. Acontece quando dois ou mais métodos possuem o mesmo nome, mas assinaturas diferentes (quantidade ou tipo dos parâmetros). Para entender melhor vamos ver um exemplo utilizando java:

		- Digamos que temos dois métodos, somaInt() e somaDouble(). E queremos somar dois números Inteiros ou Double:

			1°  public class Test {
			2°      // métodos
			3°      public int somaInt(int a, int b) {
			4°          return a + b;
			5°      }
			6°      public double somaDouble(double a, double b) {
			7°          return a + b;
			8°      }
			9°      // main
			10°     public static void main(String[] args) {
			11°         Test obj = new Test();
			12°         
			13°         System.out.println(obj.somaInt(2, 2));
			14°         System.out.println(obj.somaDouble(2.5, 2.5));
			15°     }
			16° }


		- Quando fazemos dessa maneira, estamos fazendo de um jeito onde temos que usar dois métodos pra fazer uma mesma coisa que é imprimir na tela. Nesse caso, podemos basicamente colocar os nomes dos métodos iguais:

			1°  public class Test {
			2°      // Métodos Overloading
			3°      public int soma(int a, int b) {
			4°          return a + b;
			5°      }
			6°  
			7°      public double soma(double a, double b) {
			8°          return a + b;
			9°      }
			10° 	// main
			11°     public static void main(String[] args) {
			12°         Test obj = new Test();
			13°         
			14°         System.out.println(obj.soma(5, 10));
			15°         System.out.println(obj.soma(5.5, 10.2));
			16°     }
			17° }

		- Agora temos o que chamamos de Overloading, também conhecido como " falso polimorfismo".


	- Suas características são: 

		- Somente acontece em compilação.

		- Mesma classe ou em uma classe filha.

		- Mesmo nome do método.

		- Parâmetros diferentes (tipo, ordem ou quantidade).

		- Retorno pode mudar, mas não é obrigatório

--------------------------------------------------------------------------------------------------->

	- Overriding (Sobrescrita): É a sobrescrita de métodos. Acontece quando uma subclasse redefine um método que já existe na superclasse, mantendo a mesma assinatura (nome, parâmetros e tipo de retorno compatível).  Para entender melhor vamos ver um exemplo, usado em herança de classes, mudando os métodos bolsaAuxilio e salario para atributos:

		- Digamos que tenha um método imprimirDados() na classe Pessoa que, tanto Estagiário e Funcionário estão herdando.

				Classe Pessoa 
				    nome:
				    idade:
				    rg:
				    cpf:

				    imprimirDados()

				      |
			______________|________________		<-- Estagiário e Funcionário então herdando os atributos
		       |      	 		       |			 e método da Classe Pessoa
		       |      	 		       |
		
		Classe Estagiário		Classe Funcionário 

		    bolsaAuxilio		    	salario


		- Só que quando tentamos imprimir os dados, por exemplo de um objeto estagiário. Não vamos ter seu atributo de bolsaAuxilio. Para solucionar isso podemos fazer uma Sobrescrita de método ou melhor dizendo um overriding, que nos dará a possibilidade de poder colocar a bolsaAuxilio dentro do método imprimirDados():


				Classe Pessoa 
				    nome:
				    idade:
				    rg:
				    cpf:

				    imprimirDados()

				      |
			______________|________________
		       |      	 		       |
		       |      	 		       |
		
		Classe Estagiário		Classe Funcionário 

		    bolsaAuxilio		    	salario
		    imprimirDados()			imprimirDados()		<-- Dentro de cada bloco de código irá o respectivo atributo, na caso de Estagiário será colocada a bolsaAuxilio.



		- Agora temos o que chamamos de Overriding, também conhecido como " verdadeiro polimorfismo".


	- Suas características são:

		- Somente acontece em tempo de execução.

		- Classes diferentes (relação de herança).

		- Mesmo nome do método.

		- Mesma lista de parâmetros (assinatura idêntica).

		- Retorno igual ou covariante (compatível).

--------------------------------------------------------------------------------------------------->

Tabela para ajudar na diferenciação: 

|-----------------------------------------||--------------------------------------------||--------------------------------------------|
|        Característica                   ||     Overloading (Sobrecarga)             	||      Overriding (Sobrescrita)              |
|-----------------------------------------||--------------------------------------------||--------------------------------------------|
| Definição                               || Mesma classe com métodos de mesmo nome,  	|| Subclasse redefine um método da            |
|                                         || mas com assinaturas diferentes.          	|| superclasse com a mesma assinatura.        |
|-----------------------------------------||--------------------------------------------||--------------------------------------------|
| Assinatura (parâmetros)                 || Diferente                                	|| Igual                                      |
|-----------------------------------------||--------------------------------------------||--------------------------------------------|
| Tipo de retorno                         || Pode ser diferente                       	|| Igual ou compatível (covariante)           |
|-----------------------------------------||--------------------------------------------||--------------------------------------------|
| Herança necessária?                     || Não                                      	|| Sim                                        |
|-----------------------------------------||--------------------------------------------||--------------------------------------------|
| Momento do polimorfismo                 || Compilação (compile-time)               	|| Execução (runtime)                         |
|-----------------------------------------||--------------------------------------------||--------------------------------------------|
| Polimorfismo real?                      || Não (falso polimorfismo)                   || Sim                                        |
|-----------------------------------------||--------------------------------------------||--------------------------------------------|
| Uso comum                               || Criar várias versões do mesmo método    	|| Alterar o comportamento herdado            |
|-----------------------------------------||--------------------------------------------||--------------------------------------------|


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

CLASSES ABSTRATAS ☺

- Classes abstratas são classes que não podem ser instanciadas diretamente e servem como modelo para outras classes. Elas são utilizadas quando você deseja definir uma estrutura base (atributos e comportamentos) que será compartilhada entre várias subclasses, mas deixando que algumas partes sejam implementadas obrigatoriamente pelas classes filhas. Usando o exemplo usado em herança de classes, vamos intender melhor sobre esse conceito de classes abstrata:

				Classe abstrata Pessoa 
				    nome:
				    idade:		<-- classe abstrata que tem o método abstrato, que obrigatoriamente
				    rg:				      tem que ser herdado pelas classes filhas
				    cpf:

				    abstrato imprimirDados()

				      |
			______________|________________
		       |      	 		       |
		       |      	 		       |
		
		Classe Estagiário		Classe Funcionário 
									       <-- classes filhas com o método que foi herdado da classes abstrata
		    bolsaAuxilio()		    	salario()
		    imprimirDados()			imprimirDados()
		    


- As principais características das classes abstratas são:

	- Não podem ser instanciadas: Não podemos criar objetos diretamente de uma classe abstrata.

	- Podem conter métodos abstratos: Métodos sem corpo (somente a assinatura), que obrigam as subclasses a implementá-los.

	- São usadas para generalização: Servem para definir um comportamento padrão para várias classes relacionadas.


- E podemos usar essas classes abstratas em algumas situações como por exemplo:

	- Quando você tem um conceito genérico que não deve ser instanciado, mas precisa servir de base para outras classes.

	- Quando quer forçar subclasses a implementar certos métodos, mas também oferecer métodos prontos.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

POLIMORFISMO ☺

- O conceito de polimorfismo, palavra com significado de " muitas formas " , pode permite que um mesmo método, função ou operador tenha diferentes comportamentos dependendo do contexto





































